
##### Vectors, Matrices, Data Frames, and Lists
##### 17 Jan 20203
##### UI


##### Vectors (cont'd)
#### Properties

## 1. Coercion 

### All atomic vectors are of the same data type. If you use c() to assemble different types, R coerces them.

### What does that mean? Well. On the totem pole it goes from logical -> integer -> double -> character. This means that R will coerce them to lowest type.

a <- c(2, 2.0)
`2 is an integer, 2.0 is a double. R coerces it to double.`

b <- c("purple", "green")
typeof(b)

d <- c(a, 2.0, 2, b)
typeof(d)

### We can also use comparison operators to yield a logical result

a <- runif(10) # type runif to access random numbers generated by R
print(a)

a < 0.5 # conditional statement yields a logical result

### Let's say we wanna know how many elements in the vector are > 0.5
sum(a > 0.5) # this reads the TRUE, FALSE logical vectors and adds all the one's you're asking for. It's summing the number of TRUE's

mean(a > 0.5) # what proportion of vector are greater than 0.5. 

mean(a) # mean hehe

##### Vectorization
## applies a condition to each element of the vector 

z <- c(10, 20, 30)
z + 1 # + 1 adds 1 to each element of the vector 

## What happens when vectors are added together?

y <- c(1,2,3)
z+y # results in "element by elements operation on the vector"

z^2

## What happens when you have vectors of different lengths? This is called Recycling

z
x <- c(1,2)
z + x #warning is issued but calculation is still made. shorter vector is always recycled. 

#### Simulating data: runif and rnorm()

runif(n=5, min =500, max =1000) #you can set guidelines of what you want

# set.seed() is an important function that helps other ppl reproduce your randomized numbers
set.seed(111) # it can be any number that can be used to represent a specific data set
runif(n=5, min=100, max=200)

### rnorm is another simulating data function. Gives you number with mean of 0 and standard deviation of 1
rnorm(6) # give me 6 random numbers with a mean of 0 and sd of 1

hist(runif(n=5, min=100, max=200)) # use hist function to get a histogram 

rnorm(n=100, mean =100, sd=30) #for rnorm you can actually set the mean and sd if you'd like.

hist(rnorm(n=100, mean =100, sd=30)) #historgram ;)

##### Matrix data structure

# 1. 2 dimension. Has rows and columns. However, only ONE type of data is allowed in data type. 


# matrix is an atomic vector organized into rows and columns. Use matrix function to create rows and columns. 

my_vec <- 1:12
m <- matrix(data=my_vec, nrow=4) 
m

m <- matrix(data=my_vec, ncol=3) #specify for column, for example. Will fill in numbers downward (column)
m

m <- matrix(data=my_vec, ncol=3, byrow=T) # byrow function to fill in
m

### the matrix function fills based on what we specify! ###

# Find our dimensions 
dim(m)
matrix(m)


#### Lists
## are like atomic vectors, BUT each elements can hold different data types and different sizes. They're a little complex.

my_list <- list(1:10, matrix(1:8, nrow=4, byrow=T), letters[1:3], pi) #make a list with 4 different elements: integers, numeric, matrix, character

class(my_list)

str(my_list) #function for structural properties of my_list

#### Subsetting lists
## using [] gives you a single item but not the elements 

my_list[4] #this gives me pi
my_list [4] - 3 # single bracket only gives you element in the slot, which is always type list. 

## To grab object itself, us [[]]
my_list[[4]] 

# Lets do some math 

my_list [[4]] -3 

my_list[[2]] #gives us matrix

my_list[2] # SINGLE BRACKETS, list compartment. 

my_list[[2]][4,1] #double brackets to extract brackets from compartment. This says "in my_list, I want the 2nd item of the 4th row, 1st column. This is 2nd dimension subsetting. 

my_list[c(1,2)] # to obtain multiple compartments of list
c(my_list[[1]], my_list[[2]]) # to obtain multiple elements within list, 


## Name list items when they are created
mylist2 <- list(Tester=F, littleM=matrix(1:9, nrow=3))
mylist2

mylist2$Tester #gives us the element of Tester # $ accesses named elements

mylist2$littleM[2,3]# extracts second row, third column of littleM

mylist2$littleM[2,] # leave col blank if you want all elements

mylist2$littleM[5] # single number gives 5th element

### Use unlist to string everything back to vector
unRolled <- unlist(mylist2) # unRolled names each element
unRolled

data("iris") # iris is a plant function  
head(iris) # head is a function that lets us see the first 6 rows
plot(Sepal.Length~Petal.Length, data = iris) # use ~ to show comparison btwn 2 stuff
model <- lm(Sepal.Length ~Petal.Length,x data=iris) # lm = linear model
model
results <- summary(model) #gives us results we're used to seeing in Excel 

str(results)
results$coefficients

# use [] to extract Petal.Length pvalue
results$coefficients["Petal.Length", "Pr(>|t|)"]
# different way: use unlist

## Data Frames
# equal=lengthened vectors, each of which is a column

varA <- 1:12
varB <- rep(c("Con", "LowN", "HighN"), each=4)

varC <- runif(12)

dFrame <- data.frame(varA, varB, varC, stringsAsFactors = FALSE)


# Add a row
newData <- list(varA=13, varB="HighN", varC=0.668)

# Use rbind()
dFrame <- rbind(dFrame, newData)

#Why can't we use c()? Why did we have to make a list to add a row?

newData2 <- c(14, "HighN", 0.668)
dFrame <- rbind(dFrame, newData2)


# Add a column

1. newVar <- runif(14) #will throw error if not the same length as row (duh, this is so every col can have a number)

2. # now use cbind function to add col 
dFrame <- cbind(dFrame, newVar) 


## Data Frames v Matrices

zMat <- matrix(data=1:30, ncol=3, byrow=T) 

zDFrame <- as.data.frame(zMat) #as functions coerse into something being a different type 

zMat[,3] #subsetting 
zDFrame[,3]
zDFrame$V3


#### Eliminating NAs


# we can use the complete.cases() function

zD <- c(NA, rnorm(10), NA, rnorm(10), NA, rnorm(3)) complete.cases(zD) #gives logical output ****CHECK THIS ONE****

# Clean out NAs
zD[complete.cases(zD)]
which(!complete.cases(zD)) 


# Use with Matrix
m <- matrix(1:20, nrow=5)
m[1,1] <- NA
m[5,4] <- NA
complete.cases(m) # gives T/F as to whether whole row is complete (no NAs)
m[complete.cases(m),]

## Get complete cases for only certain rows
m[complete.cases(m[,c(1:2)]),] 

#### Matrices example

m <- matrix(data=1:12, nrow=3)

### Subset by elements using a colon 

m[1:2, ]
m[,2:4]

# Subset by elements using logical statements
# Logical operators: ==, !, >, <, =

colSums(m) > 15 #select all columns for which totals are > 15
m[,colSums(m)>15] #subsets based on those conditions
m[rowSums(m)==22,] #select all rows which equal 22
m[rowSums(m)!=22,] #select all rows which do not equal to 22

# Subset to a vector changes the data type
z <- m[1,]
str(z)

z2 <- m[1, ,drop=F] #subset a matrix and keep it as a matrix

# Making new Matrices
m2 <- matrix(data=runif(9), nrow=3)

##Create data frame

data <-iris
head(data) #use head function to see first 6 options
tail(data) #use tail function to see last 6 options

data[[3,2]] #numbered indices still work, but it's better to use the names

dataSub <- data[,c("Species", "Petal.Length")]
str(dataSub)

##Sorting DataFrames by value

orderedIris <- iris[order(iris$Petal.Length), ] #use $to extract whole column
head(orderedIris) 

### Functions

# everything in R is a function!

sum(3, 2) # In 3 +2, the + is a function

### User-defined functions 

functionName <- function(argX=default){} #curly bracket starts the line of the function
###Lines of R code ### and notes
###create local variable (only visible to R within the function)

# Return vs Print 
# Print = let me know what's in the variable
# Return = if you return a variable, you can make it part of the local variable

myFunc <- function(a=3, b=4){
  z <- a+b
  return(z)
}
myFunc() #returns whatever is inside the functionparenthesis

myFunc(a=100, b=3.4) # you can change code within PARENTHESIS. That is the benefit of using them

myFuncBad <- function(a=30{
  z <- a+b
  return(z)
} # example of bad function. 'b' is not defined so it will output an error

###################################################### Best way to annotate function is to have A LOT of hashatags
# FUNCTION: HardyWeinberg
# input: all allele frequency p (0,1)
# output: p and the frequencies of 3 genotypes AA AB BB

#------------------------------------------------------------------------
###EXAMPLE 1 OF FUNCTIONS

HardyWeisberg <- function(p=runif(1)){if(p>1.0|p<0.0){ 
  return("Function failure: p must be between 0 and 1")
  }
  q <- 1-p
  fAA <- p^2
  fAB <- 2*p*q
  fBB <- q^2
  vecOut <- signif(c(p=p, AA=fAA, AB=fAB, BB=fBB), digits=3)
  return(vecOut) }
#######################################################

HardyWeisberg()
freqs <- HardyWeisberg()

#---------------------------------------------------------------------

####### Create a more complex default value using if statement. If statements allows you to inoput something as a list of two different vectors of numeric value. Or, if it is empty, it qill create values for you

#############################
#FUNCTION: fitlinear2
#fits a simple regression line
# input: numeric list (p) of predictor (x) and response (y)
#output: slope and p-value

#-------------------------------------------------------------------------
##EXAMPLE 2 OF FUNCTIONS

fitLinear2 <- function(p=NULL){
  if(is.null(p)){
    p <- list(x=runif(20), y=runif(20))
  }
  myMod <- lm(p$x~p$y)
  myOut <- c(slope=summary(myMod)$coefficients[2,1], 
             pValue = summary(myMod)$coefficients[2,4]) 
  plot(x=p$x, y=p$y) 
  return(myOut)
}
fitLinear2()

myPars <- list(x=1:10, y=runif(10)) #Let's add some more descriptors 
fitLinear2(p=myPars)
# ------------------------------------------------------------------------
  
  
  
  
  